{"mappings":"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","sources":["./packages/react/tooltip/src/createStateMachine.tsx","./packages/react/tooltip/src/tooltipStateChart.tsx","./packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["const ASSIGN_ACTION_TYPE = 'machine.actions.assign' as const;\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\ntype StateChart<State extends string, Context, Event extends { type: string }> = {\n  initial: State;\n  context: Context;\n  on?: {\n    [eventType in Event['type']]?: Transition<State, Context, Event>;\n  };\n  states: {\n    [stateValue in State]: {\n      on?: {\n        [eventType in Event['type']]?: Transition<State, Context, Event>;\n      };\n      entry?: Array<Action<Context, Event>>;\n      exit?: Array<Action<Context, Event>>;\n    };\n  };\n};\n\ntype Transition<State extends string, Context, Event> = {\n  target?: State;\n  actions?: Array<Action<Context, Event>>;\n  cond?: (context: Context, Event: Event) => boolean;\n};\n\ntype Action<Context, Event> = ActionFunction<Context, Event> | AssignAction<Context, Event>;\n\ntype ActionFunction<Context, Event> = (\n  context: Context,\n  event: Event,\n  send: (event: Event) => void\n) => void;\n\nfunction createStateMachine<State extends string, Context, Event extends { type: string }>(\n  stateChart: StateChart<State, Context, Event>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let currentState = stateChart.initial;\n  let currentContext = stateChart.context;\n\n  type CallbackFn = (args: { state: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) => callback({ state: currentState, context: currentContext }));\n  }\n\n  const send = (event: Event) => {\n    const stateDefinition = stateChart.states[currentState];\n    const type: Event['type'] | undefined = event.type;\n    const topLevelTransition: Transition<State, Context, Event> | undefined = stateChart.on?.[type];\n    const stateTransition: Transition<State, Context, Event> | undefined =\n      stateDefinition.on?.[type];\n    const transition = topLevelTransition ?? stateTransition;\n\n    if (transition === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(\n          `From state: \"${currentState}\", event \"${type}\" has no transition to any state`\n        );\n      }\n    } else {\n      const { target: nextState, actions = [], cond = () => true } = transition;\n      const nextStateDefinition = nextState ? stateChart.states[nextState] : {};\n\n      if (cond(currentContext, event)) {\n        // execute actions\n        const allActions = (stateDefinition.exit || []).concat(\n          actions,\n          nextStateDefinition.entry || []\n        );\n        currentContext = executeActions(allActions, event, currentContext);\n\n        if (nextState) {\n          currentState = nextState;\n\n          if (debug) {\n            console.group('event:', event);\n            console.log('state:', currentState);\n            console.log('context:', currentContext);\n            console.groupEnd();\n          }\n\n          notify();\n        }\n      }\n    }\n  };\n\n  function getContext() {\n    return currentContext;\n  }\n\n  function executeActions(\n    actions: Array<Action<Context, Event>>,\n    event: Event,\n    context: Context\n  ): Context {\n    let nextContext = context;\n    actions?.forEach((action) => {\n      if (typeof action === 'function') {\n        action(nextContext, event, send);\n      } else if (action.type === ASSIGN_ACTION_TYPE) {\n        nextContext = action.assign(nextContext, event);\n      }\n    });\n    return nextContext;\n  }\n\n  return { subscribe, send, getContext };\n}\n\ntype AssignAction<Context, Event> = {\n  type: typeof ASSIGN_ACTION_TYPE;\n  assign(context: Context, event: Event): Context;\n};\n\nfunction assign<Context, Event>(\n  assignFn: AssignAction<Context, Event>['assign']\n): AssignAction<Context, Event> {\n  return { type: ASSIGN_ACTION_TYPE, assign: assignFn };\n}\n\nexport { createStateMachine, assign };\nexport type { StateChart, Action };\n","import { assign } from './createStateMachine';\n\nimport type { StateChart, Action } from './createStateMachine';\n\ntype TooltipState = 'closed' | 'opening' | 'open' | 'closing';\n\ntype TooltipEvent =\n  | { type: 'OPEN'; id: string; delayDuration?: number }\n  | { type: 'CLOSE'; id: string; skipDelayDuration: number }\n  | { type: 'FOCUS'; id: string }\n  | { type: 'DELAY_TIMER_END' }\n  | { type: 'SKIP_DELAY_TIMER_END' };\n\ntype TooltipContext = { id: string | null; delayed: boolean };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipContext, TooltipEvent>;\ntype TooltipAction = Action<TooltipContext, TooltipEvent>;\n\n// actions\nlet delayTimerId: number;\nlet skipDelayTimerId: number;\n\nconst startDelayTimer: TooltipAction = (context, event, send) => {\n  const delayDuration: number | undefined = (event as any).delayDuration;\n  const sendTimerEnd = () => send({ type: 'DELAY_TIMER_END' });\n  if (delayDuration === undefined) {\n    sendTimerEnd();\n  } else {\n    delayTimerId = window.setTimeout(sendTimerEnd, delayDuration);\n  }\n};\n\nconst cancelDelayTimer: TooltipAction = () => clearTimeout(delayTimerId);\n\nconst startSkipDelayTimer: TooltipAction = (context, event, send) => {\n  const skipDelayDuration: number = (event as any).skipDelayDuration ?? 300;\n  skipDelayTimerId = window.setTimeout(\n    () => send({ type: 'SKIP_DELAY_TIMER_END' }),\n    skipDelayDuration\n  );\n};\n\nconst cancelSkipDelayTimer: TooltipAction = () => clearTimeout(skipDelayTimerId);\n\nconst setId: TooltipAction = assign((context, event) => ({\n  ...context,\n  id: (event as any).id ?? context.id,\n}));\nconst resetId: TooltipAction = assign((context) => ({ ...context, id: null }));\nconst setDelayed: TooltipAction = assign((context) => ({ ...context, delayed: true }));\nconst resetDelayed: TooltipAction = assign((context) => ({ ...context, delayed: false }));\n\nconst tooltipStateChart: TooltipStateChart = {\n  initial: 'closed',\n  context: { id: null, delayed: false },\n  on: {\n    FOCUS: { target: 'open' },\n  },\n  states: {\n    closed: {\n      entry: [resetId],\n      on: {\n        OPEN: { target: 'opening' },\n      },\n    },\n\n    opening: {\n      entry: [startDelayTimer, setId, setDelayed],\n      exit: [cancelDelayTimer],\n      on: {\n        DELAY_TIMER_END: { target: 'open' },\n        CLOSE: { target: 'closed' },\n      },\n    },\n\n    open: {\n      entry: [setId],\n      exit: [resetDelayed],\n      on: {\n        OPEN: { target: 'open' },\n        CLOSE: {\n          target: 'closing',\n          cond: (context, event) => context.id === (event as any).id,\n        },\n      },\n    },\n\n    closing: {\n      entry: [startSkipDelayTimer],\n      exit: [cancelSkipDelayTimer],\n      on: {\n        OPEN: { target: 'open' },\n        SKIP_DELAY_TIMER_END: { target: 'closed' },\n      },\n    },\n  },\n};\n\nexport { tooltipStateChart };\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useRect } from '@radix-ui/react-use-rect';\nimport { Presence } from '@radix-ui/react-presence';\nimport { extendPrimitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Slottable } from '@radix-ui/react-slot';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\nimport { useId } from '@radix-ui/react-id';\nimport { createStateMachine } from './createStateMachine';\nimport { tooltipStateChart } from './tooltipStateChart';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\nconst stateMachine = createStateMachine(tooltipStateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipContextValue = {\n  contentId: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n  trigger: React.ElementRef<typeof TooltipTrigger> | null;\n  onTriggerChange(trigger: React.ElementRef<typeof TooltipTrigger> | null): void;\n  onFocus(): void;\n  onOpen(): void;\n  onClose(): void;\n};\n\nconst [TooltipProvider, useTooltipContext] = createContext<TooltipContextValue>(TOOLTIP_NAME);\n\ntype TooltipOwnProps = {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n\n  /**\n   * The duration from when the mouse enters the trigger until the tooltip gets opened.\n   * (default: 700)\n   */\n  delayDuration?: number;\n\n  /**\n   * How much time a user has to enter another trigger without incurring a delay again.\n   * (default: 300)\n   */\n  skipDelayDuration?: number;\n};\n\nconst Tooltip: React.FC<TooltipOwnProps> = (props) => {\n  const {\n    children,\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    delayDuration = 700,\n    skipDelayDuration = 300,\n  } = props;\n  const [trigger, setTrigger] = React.useState<HTMLButtonElement | null>(null);\n  const contentId = useId();\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'open' && context.id === contentId) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (context.id === contentId) {\n        if (state === 'open') {\n          setStateAttribute(context.delayed ? 'delayed-open' : 'instant-open');\n        } else {\n          setStateAttribute('closed');\n        }\n      } else {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId]);\n\n  const handleFocus = React.useCallback(() => stateMachine.send({ type: 'FOCUS', id: contentId }), [\n    contentId,\n  ]);\n  const handleOpen = React.useCallback(\n    () => stateMachine.send({ type: 'OPEN', id: contentId, delayDuration }),\n    [contentId, delayDuration]\n  );\n  const handleClose = React.useCallback(\n    () => stateMachine.send({ type: 'CLOSE', id: contentId, skipDelayDuration }),\n    [skipDelayDuration, contentId]\n  );\n\n  // send transition if the component unmounts\n  React.useEffect(() => () => handleClose(), [handleClose]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.send({ type: 'OPEN', id: contentId });\n    }\n  }, [contentId, openProp]);\n\n  return (\n    <PopperPrimitive.Root>\n      <TooltipProvider\n        contentId={contentId}\n        open={open}\n        stateAttribute={stateAttribute}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        onFocus={handleFocus}\n        onOpen={handleOpen}\n        onClose={handleClose}\n      >\n        {children}\n      </TooltipProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\nconst TRIGGER_DEFAULT_TAG = 'button';\n\ntype TooltipTriggerOwnProps = Omit<\n  Polymorphic.OwnProps<typeof PopperPrimitive.Anchor>,\n  'virtualRef'\n>;\ntype TooltipTriggerPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TRIGGER_DEFAULT_TAG,\n  TooltipTriggerOwnProps\n>;\n\nconst TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const { as = TRIGGER_DEFAULT_TAG, ...triggerProps } = props;\n  const context = useTooltipContext(TRIGGER_NAME);\n  const composedTriggerRef = useComposedRefs(forwardedRef, (node) => context.onTriggerChange(node));\n\n  return (\n    <PopperPrimitive.Anchor\n      type=\"button\"\n      aria-describedby={context.open ? context.contentId : undefined}\n      data-state={context.stateAttribute}\n      {...triggerProps}\n      as={as}\n      ref={composedTriggerRef}\n      onMouseEnter={composeEventHandlers(props.onMouseEnter, context.onOpen)}\n      onMouseLeave={composeEventHandlers(props.onMouseLeave, context.onClose)}\n      onMouseDown={composeEventHandlers(props.onMouseDown, context.onClose)}\n      onFocus={composeEventHandlers(props.onFocus, context.onFocus)}\n      onBlur={composeEventHandlers(props.onBlur, context.onClose)}\n      onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n        if (event.key === 'Enter' || event.key === ' ') {\n          context.onClose();\n        }\n      })}\n    />\n  );\n}) as TooltipTriggerPrimitive;\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof TooltipContentImpl>,\n  {\n    /**\n     * Used to force mounting when more control is needed. Useful when\n     * controlling animation with React animation libraries.\n     */\n    forceMount?: true;\n  }\n>;\n\ntype TooltipContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof TooltipContentImpl>,\n  TooltipContentOwnProps\n>;\n\nconst TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const { forceMount, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  return (\n    <Presence present={forceMount || context.open}>\n      <TooltipContentImpl ref={forwardedRef} {...contentProps} />\n    </Presence>\n  );\n}) as TooltipContentPrimitive;\n\ntype TooltipContentImplOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof PopperPrimitive.Content>,\n  {\n    /**\n     * A more descriptive label for accessibility purpose\n     */\n    'aria-label'?: string;\n\n    /**\n     * Whether the Tooltip should render in a Portal\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype TooltipContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Content>,\n  TooltipContentImplOwnProps\n>;\n\nconst TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const { children, 'aria-label': ariaLabel, portalled = true, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n\n  useEscapeKeydown(() => context.onClose());\n\n  return (\n    <PortalWrapper>\n      <CheckTriggerMoved />\n      <PopperPrimitive.Content\n        data-state={context.stateAttribute}\n        {...contentProps}\n        ref={forwardedRef}\n        style={{\n          ...contentProps.style,\n          // re-namespace exposed content custom property\n          ['--radix-tooltip-content-transform-origin' as any]: 'var(--radix-popper-transform-origin)',\n        }}\n      >\n        <Slottable>{children}</Slottable>\n        <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n          {ariaLabel || children}\n        </VisuallyHiddenPrimitive.Root>\n      </PopperPrimitive.Content>\n    </PortalWrapper>\n  );\n}) as TooltipContentImplPrimitive;\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst TooltipArrow = extendPrimitive(PopperPrimitive.Arrow, { displayName: 'TooltipArrow' });\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved() {\n  const context = useTooltipContext('CheckTriggerMoved');\n\n  const triggerRect = useRect(context.trigger);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n  const handleClose = context.onClose;\n\n  React.useEffect(() => {\n    // checking if the user has scrolled…\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      handleClose();\n    }\n  }, [handleClose, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\nexport type { TooltipTriggerPrimitive, TooltipContentPrimitive };\n"],"names":["assign","assignFn","type","delayTimerId","skipDelayTimerId","setId","$ef54466d8a95ecaa234e3ec978fbe68$export$assign","context","event","_id","id","stateMachine","stateChart","debug","warnOnUnknownTransitions","currentState","initial","currentContext","subscriptions","send","_stateChart$on","_stateDefinition$on","stateDefinition","states","topLevelTransition","on","stateTransition","transition","undefined","console","warn","target","nextState","actions","cond","nextStateDefinition","allActions","exit","concat","entry","nextContext","forEach","action","executeActions","group","log","groupEnd","callback","state","subscribe","push","splice","indexOf","getContext","$ef54466d8a95ecaa234e3ec978fbe68$export$createStateMachine","delayed","FOCUS","closed","OPEN","opening","delayDuration","sendTimerEnd","window","setTimeout","clearTimeout","DELAY_TIMER_END","CLOSE","open","closing","_skipDelayDuration","skipDelayDuration","SKIP_DELAY_TIMER_END","TooltipProvider","useTooltipContext","createContext","Tooltip","props","children","openProp","defaultOpen","onOpenChange","trigger","setTrigger","React","useState","contentId","useId","setOpen","useControllableState","prop","defaultProp","onChange","stateAttribute","setStateAttribute","useEffect","handleFocus","useCallback","handleOpen","handleClose","useLayoutEffect","_react","createElement","_radixUiReactPopper","Root","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipProvider","onTriggerChange","onFocus","onOpen","onClose","TRIGGER_DEFAULT_TAG","TooltipTrigger","forwardRef","forwardedRef","as","triggerProps","composedTriggerRef","useComposedRefs","node","Anchor","_babelRuntimeHelpersEsmExtends","aria-describedby","data-state","ref","onMouseEnter","composeEventHandlers","onMouseLeave","onMouseDown","onBlur","onKeyDown","key","TooltipContent","forceMount","contentProps","Presence","present","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$TooltipContentImpl","TooltipContentImpl","aria-label","ariaLabel","portalled","PortalWrapper","Portal","Fragment","useEscapeKeydown","$badf5d6f88b7e9fa4e0bb85d71c0396a$var$CheckTriggerMoved","Content","style","--radix-tooltip-content-transform-origin","Slottable","_radixUiReactVisuallyHidden","role","TooltipArrow","extendPrimitive","PopperPrimitive","Arrow","displayName","CheckTriggerMoved","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger"],"version":3,"file":"index.module.js.map"}