{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./packages/react/tooltip/src/createStateMachine.tsx","./packages/react/tooltip/src/tooltipStateChart.tsx","./packages/react/tooltip/src/Tooltip.tsx"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$reexport(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n\nvar $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n","const ASSIGN_ACTION_TYPE = 'machine.actions.assign' as const;\n\nconst isProduction = process.env.NODE_ENV === 'production';\n\ntype StateChart<State extends string, Context, Event extends { type: string }> = {\n  initial: State;\n  context: Context;\n  on?: {\n    [eventType in Event['type']]?: Transition<State, Context, Event>;\n  };\n  states: {\n    [stateValue in State]: {\n      on?: {\n        [eventType in Event['type']]?: Transition<State, Context, Event>;\n      };\n      entry?: Array<Action<Context, Event>>;\n      exit?: Array<Action<Context, Event>>;\n    };\n  };\n};\n\ntype Transition<State extends string, Context, Event> = {\n  target?: State;\n  actions?: Array<Action<Context, Event>>;\n  cond?: (context: Context, Event: Event) => boolean;\n};\n\ntype Action<Context, Event> = ActionFunction<Context, Event> | AssignAction<Context, Event>;\n\ntype ActionFunction<Context, Event> = (\n  context: Context,\n  event: Event,\n  send: (event: Event) => void\n) => void;\n\nfunction createStateMachine<State extends string, Context, Event extends { type: string }>(\n  stateChart: StateChart<State, Context, Event>,\n  { debug = false, warnOnUnknownTransitions = !isProduction } = {}\n) {\n  let currentState = stateChart.initial;\n  let currentContext = stateChart.context;\n\n  type CallbackFn = (args: { state: State; context: Context }) => void;\n  const subscriptions: Array<CallbackFn> = [];\n\n  function subscribe(callback: CallbackFn) {\n    subscriptions.push(callback);\n    return () => {\n      subscriptions.splice(subscriptions.indexOf(callback), 1);\n    };\n  }\n\n  function notify() {\n    subscriptions.forEach((callback) => callback({ state: currentState, context: currentContext }));\n  }\n\n  const send = (event: Event) => {\n    const stateDefinition = stateChart.states[currentState];\n    const type: Event['type'] | undefined = event.type;\n    const topLevelTransition: Transition<State, Context, Event> | undefined = stateChart.on?.[type];\n    const stateTransition: Transition<State, Context, Event> | undefined =\n      stateDefinition.on?.[type];\n    const transition = topLevelTransition ?? stateTransition;\n\n    if (transition === undefined) {\n      if (warnOnUnknownTransitions) {\n        console.warn(\n          `From state: \"${currentState}\", event \"${type}\" has no transition to any state`\n        );\n      }\n    } else {\n      const { target: nextState, actions = [], cond = () => true } = transition;\n      const nextStateDefinition = nextState ? stateChart.states[nextState] : {};\n\n      if (cond(currentContext, event)) {\n        // execute actions\n        const allActions = (stateDefinition.exit || []).concat(\n          actions,\n          nextStateDefinition.entry || []\n        );\n        currentContext = executeActions(allActions, event, currentContext);\n\n        if (nextState) {\n          currentState = nextState;\n\n          if (debug) {\n            console.group('event:', event);\n            console.log('state:', currentState);\n            console.log('context:', currentContext);\n            console.groupEnd();\n          }\n\n          notify();\n        }\n      }\n    }\n  };\n\n  function getContext() {\n    return currentContext;\n  }\n\n  function executeActions(\n    actions: Array<Action<Context, Event>>,\n    event: Event,\n    context: Context\n  ): Context {\n    let nextContext = context;\n    actions?.forEach((action) => {\n      if (typeof action === 'function') {\n        action(nextContext, event, send);\n      } else if (action.type === ASSIGN_ACTION_TYPE) {\n        nextContext = action.assign(nextContext, event);\n      }\n    });\n    return nextContext;\n  }\n\n  return { subscribe, send, getContext };\n}\n\ntype AssignAction<Context, Event> = {\n  type: typeof ASSIGN_ACTION_TYPE;\n  assign(context: Context, event: Event): Context;\n};\n\nfunction assign<Context, Event>(\n  assignFn: AssignAction<Context, Event>['assign']\n): AssignAction<Context, Event> {\n  return { type: ASSIGN_ACTION_TYPE, assign: assignFn };\n}\n\nexport { createStateMachine, assign };\nexport type { StateChart, Action };\n","import { assign } from './createStateMachine';\n\nimport type { StateChart, Action } from './createStateMachine';\n\ntype TooltipState = 'closed' | 'opening' | 'open' | 'closing';\n\ntype TooltipEvent =\n  | { type: 'OPEN'; id: string; delayDuration?: number }\n  | { type: 'CLOSE'; id: string; skipDelayDuration: number }\n  | { type: 'FOCUS'; id: string }\n  | { type: 'DELAY_TIMER_END' }\n  | { type: 'SKIP_DELAY_TIMER_END' };\n\ntype TooltipContext = { id: string | null; delayed: boolean };\n\ntype TooltipStateChart = StateChart<TooltipState, TooltipContext, TooltipEvent>;\ntype TooltipAction = Action<TooltipContext, TooltipEvent>;\n\n// actions\nlet delayTimerId: number;\nlet skipDelayTimerId: number;\n\nconst startDelayTimer: TooltipAction = (context, event, send) => {\n  const delayDuration: number | undefined = (event as any).delayDuration;\n  const sendTimerEnd = () => send({ type: 'DELAY_TIMER_END' });\n  if (delayDuration === undefined) {\n    sendTimerEnd();\n  } else {\n    delayTimerId = window.setTimeout(sendTimerEnd, delayDuration);\n  }\n};\n\nconst cancelDelayTimer: TooltipAction = () => clearTimeout(delayTimerId);\n\nconst startSkipDelayTimer: TooltipAction = (context, event, send) => {\n  const skipDelayDuration: number = (event as any).skipDelayDuration ?? 300;\n  skipDelayTimerId = window.setTimeout(\n    () => send({ type: 'SKIP_DELAY_TIMER_END' }),\n    skipDelayDuration\n  );\n};\n\nconst cancelSkipDelayTimer: TooltipAction = () => clearTimeout(skipDelayTimerId);\n\nconst setId: TooltipAction = assign((context, event) => ({\n  ...context,\n  id: (event as any).id ?? context.id,\n}));\nconst resetId: TooltipAction = assign((context) => ({ ...context, id: null }));\nconst setDelayed: TooltipAction = assign((context) => ({ ...context, delayed: true }));\nconst resetDelayed: TooltipAction = assign((context) => ({ ...context, delayed: false }));\n\nconst tooltipStateChart: TooltipStateChart = {\n  initial: 'closed',\n  context: { id: null, delayed: false },\n  on: {\n    FOCUS: { target: 'open' },\n  },\n  states: {\n    closed: {\n      entry: [resetId],\n      on: {\n        OPEN: { target: 'opening' },\n      },\n    },\n\n    opening: {\n      entry: [startDelayTimer, setId, setDelayed],\n      exit: [cancelDelayTimer],\n      on: {\n        DELAY_TIMER_END: { target: 'open' },\n        CLOSE: { target: 'closed' },\n      },\n    },\n\n    open: {\n      entry: [setId],\n      exit: [resetDelayed],\n      on: {\n        OPEN: { target: 'open' },\n        CLOSE: {\n          target: 'closing',\n          cond: (context, event) => context.id === (event as any).id,\n        },\n      },\n    },\n\n    closing: {\n      entry: [startSkipDelayTimer],\n      exit: [cancelSkipDelayTimer],\n      on: {\n        OPEN: { target: 'open' },\n        SKIP_DELAY_TIMER_END: { target: 'closed' },\n      },\n    },\n  },\n};\n\nexport { tooltipStateChart };\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useRect } from '@radix-ui/react-use-rect';\nimport { Presence } from '@radix-ui/react-presence';\nimport { extendPrimitive } from '@radix-ui/react-primitive';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Slottable } from '@radix-ui/react-slot';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\nimport { useId } from '@radix-ui/react-id';\nimport { createStateMachine } from './createStateMachine';\nimport { tooltipStateChart } from './tooltipStateChart';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\n/* -------------------------------------------------------------------------------------------------\n * State machine\n * -----------------------------------------------------------------------------------------------*/\n\ntype StateAttribute = 'closed' | 'delayed-open' | 'instant-open';\nconst stateMachine = createStateMachine(tooltipStateChart);\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipContextValue = {\n  contentId: string;\n  open: boolean;\n  stateAttribute: StateAttribute;\n  trigger: React.ElementRef<typeof TooltipTrigger> | null;\n  onTriggerChange(trigger: React.ElementRef<typeof TooltipTrigger> | null): void;\n  onFocus(): void;\n  onOpen(): void;\n  onClose(): void;\n};\n\nconst [TooltipProvider, useTooltipContext] = createContext<TooltipContextValue>(TOOLTIP_NAME);\n\ntype TooltipOwnProps = {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n\n  /**\n   * The duration from when the mouse enters the trigger until the tooltip gets opened.\n   * (default: 700)\n   */\n  delayDuration?: number;\n\n  /**\n   * How much time a user has to enter another trigger without incurring a delay again.\n   * (default: 300)\n   */\n  skipDelayDuration?: number;\n};\n\nconst Tooltip: React.FC<TooltipOwnProps> = (props) => {\n  const {\n    children,\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    delayDuration = 700,\n    skipDelayDuration = 300,\n  } = props;\n  const [trigger, setTrigger] = React.useState<HTMLButtonElement | null>(null);\n  const contentId = useId();\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [stateAttribute, setStateAttribute] = React.useState<StateAttribute>(\n    openProp ? 'instant-open' : 'closed'\n  );\n\n  // control open state using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (state === 'open' && context.id === contentId) {\n        setOpen(true);\n      } else {\n        setOpen(false);\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId, setOpen]);\n\n  // sync state attribute with using state machine subscription\n  React.useEffect(() => {\n    const unsubscribe = stateMachine.subscribe(({ state, context }) => {\n      if (context.id === contentId) {\n        if (state === 'open') {\n          setStateAttribute(context.delayed ? 'delayed-open' : 'instant-open');\n        } else {\n          setStateAttribute('closed');\n        }\n      } else {\n        setStateAttribute('closed');\n      }\n    });\n\n    return unsubscribe;\n  }, [contentId]);\n\n  const handleFocus = React.useCallback(() => stateMachine.send({ type: 'FOCUS', id: contentId }), [\n    contentId,\n  ]);\n  const handleOpen = React.useCallback(\n    () => stateMachine.send({ type: 'OPEN', id: contentId, delayDuration }),\n    [contentId, delayDuration]\n  );\n  const handleClose = React.useCallback(\n    () => stateMachine.send({ type: 'CLOSE', id: contentId, skipDelayDuration }),\n    [skipDelayDuration, contentId]\n  );\n\n  // send transition if the component unmounts\n  React.useEffect(() => () => handleClose(), [handleClose]);\n\n  // if we're controlling the component\n  // put the state machine in the appropriate state\n  useLayoutEffect(() => {\n    if (openProp === true) {\n      stateMachine.send({ type: 'OPEN', id: contentId });\n    }\n  }, [contentId, openProp]);\n\n  return (\n    <PopperPrimitive.Root>\n      <TooltipProvider\n        contentId={contentId}\n        open={open}\n        stateAttribute={stateAttribute}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        onFocus={handleFocus}\n        onOpen={handleOpen}\n        onClose={handleClose}\n      >\n        {children}\n      </TooltipProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\nconst TRIGGER_DEFAULT_TAG = 'button';\n\ntype TooltipTriggerOwnProps = Omit<\n  Polymorphic.OwnProps<typeof PopperPrimitive.Anchor>,\n  'virtualRef'\n>;\ntype TooltipTriggerPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TRIGGER_DEFAULT_TAG,\n  TooltipTriggerOwnProps\n>;\n\nconst TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const { as = TRIGGER_DEFAULT_TAG, ...triggerProps } = props;\n  const context = useTooltipContext(TRIGGER_NAME);\n  const composedTriggerRef = useComposedRefs(forwardedRef, (node) => context.onTriggerChange(node));\n\n  return (\n    <PopperPrimitive.Anchor\n      type=\"button\"\n      aria-describedby={context.open ? context.contentId : undefined}\n      data-state={context.stateAttribute}\n      {...triggerProps}\n      as={as}\n      ref={composedTriggerRef}\n      onMouseEnter={composeEventHandlers(props.onMouseEnter, context.onOpen)}\n      onMouseLeave={composeEventHandlers(props.onMouseLeave, context.onClose)}\n      onMouseDown={composeEventHandlers(props.onMouseDown, context.onClose)}\n      onFocus={composeEventHandlers(props.onFocus, context.onFocus)}\n      onBlur={composeEventHandlers(props.onBlur, context.onClose)}\n      onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n        if (event.key === 'Enter' || event.key === ' ') {\n          context.onClose();\n        }\n      })}\n    />\n  );\n}) as TooltipTriggerPrimitive;\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof TooltipContentImpl>,\n  {\n    /**\n     * Used to force mounting when more control is needed. Useful when\n     * controlling animation with React animation libraries.\n     */\n    forceMount?: true;\n  }\n>;\n\ntype TooltipContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof TooltipContentImpl>,\n  TooltipContentOwnProps\n>;\n\nconst TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const { forceMount, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  return (\n    <Presence present={forceMount || context.open}>\n      <TooltipContentImpl ref={forwardedRef} {...contentProps} />\n    </Presence>\n  );\n}) as TooltipContentPrimitive;\n\ntype TooltipContentImplOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof PopperPrimitive.Content>,\n  {\n    /**\n     * A more descriptive label for accessibility purpose\n     */\n    'aria-label'?: string;\n\n    /**\n     * Whether the Tooltip should render in a Portal\n     * (default: `true`)\n     */\n    portalled?: boolean;\n  }\n>;\n\ntype TooltipContentImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof PopperPrimitive.Content>,\n  TooltipContentImplOwnProps\n>;\n\nconst TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const { children, 'aria-label': ariaLabel, portalled = true, ...contentProps } = props;\n  const context = useTooltipContext(CONTENT_NAME);\n  const PortalWrapper = portalled ? Portal : React.Fragment;\n\n  useEscapeKeydown(() => context.onClose());\n\n  return (\n    <PortalWrapper>\n      <CheckTriggerMoved />\n      <PopperPrimitive.Content\n        data-state={context.stateAttribute}\n        {...contentProps}\n        ref={forwardedRef}\n        style={{\n          ...contentProps.style,\n          // re-namespace exposed content custom property\n          ['--radix-tooltip-content-transform-origin' as any]: 'var(--radix-popper-transform-origin)',\n        }}\n      >\n        <Slottable>{children}</Slottable>\n        <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n          {ariaLabel || children}\n        </VisuallyHiddenPrimitive.Root>\n      </PopperPrimitive.Content>\n    </PortalWrapper>\n  );\n}) as TooltipContentImplPrimitive;\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst TooltipArrow = extendPrimitive(PopperPrimitive.Arrow, { displayName: 'TooltipArrow' });\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction CheckTriggerMoved() {\n  const context = useTooltipContext('CheckTriggerMoved');\n\n  const triggerRect = useRect(context.trigger);\n  const triggerLeft = triggerRect?.left;\n  const previousTriggerLeft = usePrevious(triggerLeft);\n  const triggerTop = triggerRect?.top;\n  const previousTriggerTop = usePrevious(triggerTop);\n  const handleClose = context.onClose;\n\n  React.useEffect(() => {\n    // checking if the user has scrolled…\n    const hasTriggerMoved =\n      (previousTriggerLeft !== undefined && previousTriggerLeft !== triggerLeft) ||\n      (previousTriggerTop !== undefined && previousTriggerTop !== triggerTop);\n\n    if (hasTriggerMoved) {\n      handleClose();\n    }\n  }, [handleClose, previousTriggerLeft, previousTriggerTop, triggerLeft, triggerTop]);\n\n  return null;\n}\n\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  Tooltip,\n  TooltipTrigger,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Root,\n  Trigger,\n  Content,\n  Arrow,\n};\nexport type { TooltipTriggerPrimitive, TooltipContentPrimitive };\n"],"names":["a","__esModule","default","$parcel$exportWildcard","dest","source","Object","keys","forEach","key","defineProperty","enumerable","get","assign","assignFn","type","delayTimerId","skipDelayTimerId","setId","$fb910db130fc9c6f19b2800f728d3b10$export$assign","context","event","_id","id","stateMachine","stateChart","debug","warnOnUnknownTransitions","currentState","initial","currentContext","subscriptions","send","_stateChart$on","_stateDefinition$on","stateDefinition","states","topLevelTransition","on","stateTransition","transition","undefined","console","warn","target","nextState","actions","cond","nextStateDefinition","allActions","exit","concat","entry","nextContext","action","executeActions","group","log","groupEnd","callback","state","subscribe","push","splice","indexOf","getContext","$fb910db130fc9c6f19b2800f728d3b10$export$createStateMachine","delayed","FOCUS","closed","OPEN","opening","delayDuration","sendTimerEnd","window","setTimeout","clearTimeout","DELAY_TIMER_END","CLOSE","open","closing","_skipDelayDuration","skipDelayDuration","SKIP_DELAY_TIMER_END","TooltipProvider","useTooltipContext","createContext","Tooltip","props","children","openProp","defaultOpen","onOpenChange","trigger","setTrigger","React","useState","contentId","useId","setOpen","useControllableState","prop","defaultProp","onChange","stateAttribute","setStateAttribute","useEffect","handleFocus","useCallback","handleOpen","handleClose","useLayoutEffect","_react","createElement","_radixUiReactPopper","Root","$bfd2ef98f93cfd0786881e49eeb6a4$var$TooltipProvider","onTriggerChange","onFocus","onOpen","onClose","TRIGGER_DEFAULT_TAG","TooltipTrigger","forwardRef","forwardedRef","as","triggerProps","composedTriggerRef","useComposedRefs","node","Anchor","_babelRuntimeHelpersExtends","aria-describedby","data-state","ref","onMouseEnter","composeEventHandlers","onMouseLeave","onMouseDown","onBlur","onKeyDown","TooltipContent","forceMount","contentProps","Presence","present","$bfd2ef98f93cfd0786881e49eeb6a4$var$TooltipContentImpl","TooltipContentImpl","aria-label","ariaLabel","portalled","PortalWrapper","Portal","Fragment","useEscapeKeydown","$bfd2ef98f93cfd0786881e49eeb6a4$var$CheckTriggerMoved","Content","style","--radix-tooltip-content-transform-origin","Slottable","_radixUiReactVisuallyHidden","role","TooltipArrow","extendPrimitive","PopperPrimitive","Arrow","displayName","CheckTriggerMoved","triggerRect","useRect","triggerLeft","left","previousTriggerLeft","usePrevious","triggerTop","top","previousTriggerTop","Trigger"],"version":3,"file":"index.js.map"}